<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/nc.png" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>NOCLIP MULTI USER DEMO</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div class="info">
      <div class="textinfo">
        <h2>
          <b style="font-size: calc(2.5vw + 2.5vh); color: orange"
            >NOCLIP BETA</b
          >
        </h2>
      </div>
      <div
        class="noclipwrap"
        style="
          position: fixed;
          width: 100%;
          height: 100%;
          display: flex;
          flex-flow: column;
          justify-content: center;
          left: 0px;
          top: 0px;
        "
      >
        <div class="noclip-circle"></div>
      </div>
    </div>

    <div class="wrapcover">
      <div class="minimapwrapper" id="minimapwrapper">
        <div id="minimap"></div>
      </div>
      <div class="data" id="data">
        <p
          style="margin: unset; margin-top: -0.7rem; font-size: 2rem"
          class="uno"
        >
          NOCLIP
        </p>
        <div class="button-stack">
          <!-- Removed 'Permission Request' button -->
          <span class="row">
            <button id="request_button">Access</button>
            <button id="clear">Reset</button>
            <button id="cache">Clear</button>
          </span>
        </div>
        <div class="sensor-readouts">
          <p id="location"></p>
          <p id="position"></p>
          <p>
            <span class="sensor-label">Orientation alpha (Z):</span>
            <span id="Orientation_a">N/A</span>
          </p>
          <p>
            <span class="sensor-label">Orientation beta (X):</span>
            <span id="Orientation_b">N/A</span>
          </p>
          <p>
            <span class="sensor-label">Orientation gamma (Y):</span>
            <span id="Orientation_g">N/A</span>
          </p>
          <p><span id="progress"></span></p>
          <div id="remotedata"></div>

          <hr style="display: none !important" />
          <p style="display: none !important">
            <span class="sensor-label">Acc. + Gravity X:</span>
            <span id="Accelerometer_gx">N/A</span>
          </p>
          <p style="display: none !important">
            <span class="sensor-label">Acc. + Gravity Y:</span>
            <span id="Accelerometer_gy">N/A</span>
          </p>
          <p style="display: none !important">
            <span class="sensor-label">Acc. + Gravity Z:</span>
            <span id="Accelerometer_gz">N/A</span>
          </p>
          <hr style="display: none !important" />
          <p style="display: none !important">
            <span class="sensor-label">Acc. X:</span>
            <span id="Accelerometer_x">N/A</span>
          </p>
          <p style="display: none !important">
            <span class="sensor-label">Acc. Y:</span>
            <span id="Accelerometer_y">N/A</span>
          </p>
          <p style="display: none !important">
            <span class="sensor-label">Acc. Z:</span>
            <span id="Accelerometer_z">N/A</span>
          </p>
          <hr style="display: none !important" />
          <p style="display: none !important">
            <span class="sensor-label">Interval (ms):</span>
            <span id="Accelerometer_i">N/A</span>
          </p>
          <hr style="display: none !important" />
          <p style="display: none !important">
            <span class="sensor-label">Gyro alpha (Z):</span>
            <span id="Gyroscope_z">N/A</span>
          </p>
          <p style="display: none !important">
            <span class="sensor-label">Gyro beta (X):</span>
            <span id="Gyroscope_x">N/A</span>
          </p>
          <p style="display: none !important">
            <span class="sensor-label">Gyro gamma (Y):</span>
            <span id="Gyroscope_y">N/A</span>
          </p>
          <hr style="display: none !important" />
          <p style="display: none !important">
            <span class="sensor-label">Total Events:</span>
            <span id="num-observed-events">0</span>
          </p>
          <p id="sensordata" style="padding-bottom: 0.2rem"></p>

          <div class="share">
            <input type="password" id="password" placeholder="Enter Password" />
            <button id="encryptDecryptBtn">Encrypt & Decrypt Lat/Lon</button>
          </div>
        </div>
      </div>
      <div class="localstats">
        <span id="localX"></span>
        <span id="localY"></span>
        <span id="localZ"></span>
        <br />
        <span id="localR"></span>
      </div>
      <div class="localchron">
        <span id="utcTime"></span>
        <br />
        <span id="localTime"></span>
        <br />
        <span id="IP"></span>
      </div>
    </div>

    <!-- MOBILE TOUCH CONTROLS -->
    <div class="touch-controls" id="touchControls">
      <div class="touch-control forward">W</div>
      <div class="touch-control left">A</div>
      <div class="touch-control right">D</div>
      <div class="touch-control mic">MIC</div>
      <div class="touch-control backward">S</div>
      <!-- Additional controls as needed -->
    </div>

    <!-- The main 3D or WebXR app container -->
    <div id="app"></div>
    <script>
      // Ensure the script runs after the DOM is fully loaded
      document.addEventListener('DOMContentLoaded', () => {
        // Get the element with the ID 'cache'
        const cacheButton = document.getElementById('cache')

        if (cacheButton) {
          // Add a click event listener to the button
          cacheButton.addEventListener('click', () => {
            // Clear the cache by performing a hard reload
            if ('caches' in window) {
              caches
                .keys()
                .then(cacheNames => {
                  cacheNames.forEach(cacheName => {
                    caches.delete(cacheName).then(deleted => {
                      console.log(`Cache '${cacheName}' deleted: ${deleted}`)
                    })
                  })
                })
                .then(() => {
                  // Reload the page
                  location.reload(true) // True forces the reload from the server
                })
            } else {
              console.warn(
                'Cache API is not supported in this browser. Performing reload only.'
              )
              location.reload(true)
            }
          })
        } else {
          console.error("Element with ID 'cache' not found.")
        }
      })
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // =========== Monitor and Remove Elements ===========
        function monitorAndRemoveElements(conditions) {
          const observer = new MutationObserver(mutations => {
            mutations.forEach(() => {
              conditions.forEach(({ tag, id, textContent }) => {
                try {
                  const elements = document.querySelectorAll(tag)
                  elements.forEach(element => {
                    const matchesId = id ? element.id === id : true
                    const matchesText = textContent
                      ? element.textContent.trim() === textContent
                      : true

                    if (matchesId && matchesText) {
                      console.warn(
                        `Attempting to remove ${tag} element ${
                          id ? `with ID "${id}"` : ''
                        } and textContent "${textContent}".`
                      )
                      element.remove()
                    }
                  })
                } catch (error) {
                  console.error(
                    `Error while attempting to remove element:`,
                    error
                  )
                }
              })
            })
          })

          observer.observe(document.body, { childList: true, subtree: true })
        }

        const conditions = [
          { tag: 'button', id: 'VRButton', textContent: 'VR NOT SUPPORTED' },
          { tag: 'a', textContent: 'WEBXR NOT AVAILABLE' }
        ]

        monitorAndRemoveElements(conditions)

        // =========== CONFIG LOADING / SAVING ===========
        const defaultConfig = {
          socketURL: 'https://full-canary-chokeberry.glitch.me/',
          modelPath: 'path/to/models/',
          fontPath: 'path/to/fonts/',
          terrain: {
            size: 100,
            segments: 100,
            scaleMultiplier: 1,
            gridSizeMeters: 250,
            gridResolution: 100,
            elevationAPI: 'https://epqs.nationalmap.gov/v1/json'
          },
          postProcessing: {
            enableFilmPass: false,
            enableRGBShift: false,
            enableFXAAPass: false,
            enableSSAARenderPass: true
          },
          permissions: {
            motionGranted: false,
            orientationGranted: false,
            locationGranted: false
          },
          audio: {
            broadcastKey: 'audio_stream',
            startBroadcastKey: 'start_audio',
            stopBroadcastKey: 'stop_audio'
          },
          localStorageKeys: {
            playerID: 'playerID',
            lastPosition: 'myLastPosition',
            terrainPoints: 'terrainPoints',
            encryptedPassword: 'encryptedPassword'
          },
          motionVars: {
            walkSpeed: 2,
            runSpeed: 7
          }
        }

        function loadConfig() {
          try {
            const saved = localStorage.getItem('CONFIG')
            return saved ? JSON.parse(saved) : defaultConfig
          } catch (e) {
            console.error('Error parsing CONFIG from localStorage:', e)
            return defaultConfig
          }
        }

        function saveConfig(config) {
          localStorage.setItem('CONFIG', JSON.stringify(config))
        }

        const CONFIG = loadConfig()
        saveConfig(CONFIG)
        window.CONFIG = CONFIG

        // =========== DEVICE DETECTION UTILITY ===========
        function isMobileDevice() {
          return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          )
        }

        // =========== GEOLOCATION + FALLBACK ===========
        function initializeGeolocation() {
          const locationElement = document.getElementById('location')
          if (!navigator.geolocation || !locationElement) {
            if (locationElement) {
              locationElement.textContent = 'Location: Not Supported'
            }
            return
          }

          const geoOptions = {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 5000
          }

          let normalLocationObtained = false

          function geoSuccess(pos) {
            normalLocationObtained = true
            const { latitude, longitude } = pos.coords
            window.latitude = latitude
            window.longitude = longitude
            if (locationElement) {
              locationElement.textContent = `Location: ${latitude.toFixed(
                5
              )}, ${longitude.toFixed(5)}`
            }
            window.dispatchEvent(new Event('locationUpdated'))
          }

          async function geoError(err) {
            console.warn('Geolocation error or denied:', err)
            if (!normalLocationObtained) {
              try {
                const response = await fetch('https://ipapi.co/json/')
                if (!response.ok) {
                  throw new Error(`HTTP error: ${response.status}`)
                }
                const data = await response.json()
                if (data.latitude && data.longitude) {
                  window.latitude = data.latitude
                  window.longitude = data.longitude
                  if (locationElement) {
                    locationElement.textContent = `Location (IP-based): ${data.latitude.toFixed(
                      5
                    )}, ${data.longitude.toFixed(5)}`
                  }
                  window.dispatchEvent(new Event('locationUpdated'))
                } else {
                  throw new Error('IP-based location incomplete')
                }
              } catch (ipError) {
                console.error('IP-based location fetch error:', ipError)
                if (locationElement) {
                  locationElement.textContent =
                    'Location: Unable to determine via IP'
                }
              }
            }
          }

          navigator.geolocation.watchPosition(geoSuccess, geoError, geoOptions)
        }

        function requestLocationPermission() {
          return new Promise(resolve => {
            if (!navigator.geolocation) {
              console.error('Geolocation not supported in this browser.')
              resolve(false)
              return
            }

            navigator.geolocation.getCurrentPosition(
              position => {
                console.log('Location permission granted.')
                resolve(true)
              },
              error => {
                console.warn('Location permission denied or error:', error)
                resolve(false)
              },
              {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 5000
              }
            )
          })
        }

        // =========== ORIENTATION & MOTION REQUESTS (iOS 13+) ===========
        async function requestSensorPermissions() {
          let motionGranted = false
          let orientationGranted = false

          if (
            window.DeviceMotionEvent &&
            typeof DeviceMotionEvent.requestPermission === 'function'
          ) {
            try {
              const perm = await DeviceMotionEvent.requestPermission()
              if (perm === 'granted') motionGranted = true
            } catch (e) {
              console.error('Motion permission request error:', e)
            }
          } else {
            motionGranted = true
          }

          if (
            isMobileDevice() &&
            window.DeviceOrientationEvent &&
            typeof DeviceOrientationEvent.requestPermission === 'function'
          ) {
            try {
              const perm = await DeviceOrientationEvent.requestPermission()
              if (perm === 'granted') orientationGranted = true
            } catch (e) {
              console.error('Orientation permission request error:', e)
            }
          } else if (!isMobileDevice()) {
            orientationGranted = false
          } else {
            orientationGranted = true
          }

          return { motionGranted, orientationGranted }
        }

        // =========== ONE-STOP PERMISSIONS =============
        async function requestAllPermissions() {
          const { motionGranted, orientationGranted } =
            await requestSensorPermissions()

          const locationGranted = await requestLocationPermission()
          if (locationGranted) {
            initializeGeolocation()
          }

          CONFIG.permissions.motionGranted = motionGranted
          CONFIG.permissions.orientationGranted = orientationGranted
          CONFIG.permissions.locationGranted = locationGranted
          saveConfig(CONFIG)

          window.dispatchEvent(new Event('appPermissionsChanged'))

          if (orientationGranted) {
            attachOrientationDebugListener()
          }

          return {
            motionGranted,
            orientationGranted,
            locationGranted
          }
        }

        function attachOrientationDebugListener() {
          window.addEventListener('deviceorientation', event => {
            const alphaEl = document.getElementById('Orientation_a')
            const betaEl = document.getElementById('Orientation_b')
            const gammaEl = document.getElementById('Orientation_g')

            if (!alphaEl || !betaEl || !gammaEl) return

            const alphaVal = (event.alpha || 0).toFixed(2)
            const betaVal = (event.beta || 0).toFixed(2)
            const gammaVal = (event.gamma || 0).toFixed(2)

            alphaEl.textContent = alphaVal
            betaEl.textContent = betaVal
            gammaEl.textContent = gammaVal

            window.orientationGlobal = {
              alpha: alphaVal,
              beta: betaVal,
              gamma: gammaVal
            }
          })
        }

        // =========== CLEAR BUTTON HANDLER ===========
        function attachClearButtonHandler() {
          const clearBtn = document.getElementById('clear')
          if (!clearBtn) return
          clearBtn.addEventListener('click', () => {
            try {
              localStorage.clear()
              console.log('Local storage cleared.')

              alert(
                'LocalStorage cleared; refresh to see changes.\nNote: Actual permission resets require user intervention in browser settings.'
              )
            } catch (err) {
              console.error('Error clearing local storage:', err)
            }
          })
        }

        // =========== TIME & IP UPDATE ===========
        function updateTime() {
          const now = new Date()
          const localTime = now.toLocaleTimeString()
          const utcTime = now.toUTCString().split(' ')[4]

          const localTimeEl = document.getElementById('localTime')
          const utcTimeEl = document.getElementById('utcTime')

          if (localTimeEl) localTimeEl.textContent = `${localTime} Local`
          if (utcTimeEl) utcTimeEl.textContent = `${utcTime} UTC`
        }

        async function fetchPublicIPAddress() {
          try {
            const res = await fetch('https://api.ipify.org?format=json')
            const data = await res.json()
            return data.ip
          } catch {
            return null
          }
        }

        async function fetchIPAddressUsingRTCPeerConnection() {
          return new Promise((resolve, reject) => {
            const pc = new RTCPeerConnection({ iceServers: [] })
            pc.createDataChannel('')
            pc.createOffer().then(offer => pc.setLocalDescription(offer))

            pc.onicecandidate = event => {
              if (event && event.candidate && event.candidate.candidate) {
                const ipMatch = event.candidate.candidate.match(
                  /(\d{1,3}(\.\d{1,3}){3})/
                )
                if (ipMatch) {
                  resolve(ipMatch[1])
                  pc.close()
                }
              }
            }

            setTimeout(() => reject('Timeout fetching IP via RTC'), 4000)
          })
        }

        async function fetchIPAddress() {
          const ipElement = document.getElementById('IP')
          if (!ipElement) return

          try {
            const rtcIP = await fetchIPAddressUsingRTCPeerConnection().catch(
              () => null
            )
            if (rtcIP) {
              ipElement.textContent = `IP Address (RTC): ${rtcIP}`
              return
            }
            const pubIP = await fetchPublicIPAddress()
            if (pubIP) {
              ipElement.textContent = `IP Address (Public): ${pubIP}`
            } else {
              ipElement.textContent = 'IP Address: Unable to fetch'
            }
          } catch (err) {
            console.error('Error fetching IP:', err)
            ipElement.textContent = 'IP Address: Error occurred'
          }
        }

        // =========== DEMO PERMISSION-BUTTON LOGIC ===========
        function initializePermissionDemo() {
          const requestButton = document.getElementById('request_button')
          if (!requestButton) {
            console.warn('No #request_button found in DOM.')
            return
          }

          requestButton.addEventListener('click', async () => {
            const result = await requestAllPermissions()
            console.log('Permissions result:', result)
          })
        }

        // =========== MINIMAP LOGIC ===========
        function initializeMinimap() {
          const TILE_URL = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
          const TILE_SIZE = 256
          const ZOOM = 13
          const MAP_SIZE = TILE_SIZE * 1

          const container = document.getElementById('minimap')
          const wrapper = document.getElementById('minimapwrapper')

          container.style.width = `${MAP_SIZE}px`
          container.style.height = `${MAP_SIZE}px`
          wrapper.style.width = `${MAP_SIZE}px`
          wrapper.style.height = `${MAP_SIZE}px`
          container.style.position = 'absolute'
          container.style.overflow = 'hidden'

          window.latitude = null
          window.longitude = null
          window.terrainPointClosest = {
            latitude: null,
            longitude: null,
            elevation: null
          }

          function latLonToTile(lat, lon, zoom) {
            const scale = 1 << zoom
            const x = ((lon + 180) / 360) * scale
            const y =
              ((1 -
                Math.log(
                  Math.tan((lat * Math.PI) / 180) +
                    1 / Math.cos((lat * Math.PI) / 180)
                ) /
                  Math.PI) /
                2) *
              scale
            return { x, y }
          }

          function latLonToPixel(lat, lon, zoom) {
            const tile = latLonToTile(lat, lon, zoom)
            return {
              x: tile.x * TILE_SIZE,
              y: tile.y * TILE_SIZE
            }
          }

          function constructMap(centerLat, centerLon) {
            container.innerHTML = ''

            const centerPixel = latLonToPixel(centerLat, centerLon, ZOOM)

            const topLeftPixel = {
              x: centerPixel.x - MAP_SIZE / 2,
              y: centerPixel.y - MAP_SIZE / 2
            }

            const startTileX = Math.floor(topLeftPixel.x / TILE_SIZE)
            const startTileY = Math.floor(topLeftPixel.y / TILE_SIZE)

            const offsetX = -(topLeftPixel.x % TILE_SIZE)
            const offsetY = -(topLeftPixel.y % TILE_SIZE)

            const tilesInX = Math.ceil(MAP_SIZE / TILE_SIZE) + 1
            const tilesInY = Math.ceil(MAP_SIZE / TILE_SIZE) + 1

            for (let dx = 0; dx < tilesInX; dx++) {
              for (let dy = 0; dy < tilesInY; dy++) {
                const tileX = startTileX + dx
                const tileY = startTileY + dy
                const tile = document.createElement('img')
                tile.src = TILE_URL.replace('{z}', ZOOM)
                  .replace('{x}', tileX)
                  .replace('{y}', tileY)
                tile.style.position = 'absolute'
                tile.style.left = `${dx * TILE_SIZE + offsetX}px`
                tile.style.top = `${dy * TILE_SIZE + offsetY}px`
                tile.style.width = `${TILE_SIZE}px`
                tile.style.height = `${TILE_SIZE}px`
                tile.onerror = () => {
                  console.error(
                    `Failed to load tile at (${tileX}, ${tileY}, ${ZOOM})`
                  )
                }
                container.appendChild(tile)
              }
            }

            function addMarker(lat, lon, className) {
              if (typeof lat !== 'number' || typeof lon !== 'number') {
                console.warn(
                  `Invalid latitude or longitude for marker (${className}). Marker not added.`
                )
                return
              }

              const pixel = latLonToPixel(lat, lon, ZOOM)
              const relativeX = pixel.x - topLeftPixel.x
              const relativeY = pixel.y - topLeftPixel.y

              if (!isFinite(relativeX) || !isFinite(relativeY)) {
                console.warn(
                  `Computed relative positions are invalid for marker (${className}). Marker not added.`
                )
                return
              }

              if (
                relativeX < 0 ||
                relativeX > MAP_SIZE ||
                relativeY < 0 ||
                relativeY > MAP_SIZE
              ) {
                return
              }

              const marker = document.createElement('div')
              marker.classList.add('marker', className)
              marker.style.left = `${relativeX}px`
              marker.style.top = `${relativeY}px`

              container.appendChild(marker)
            }

            if (window.latitude !== null && window.longitude !== null) {
              addMarker(window.latitude, window.longitude, 'current-location')
            }

            if (
              window.terrainPointClosest &&
              typeof window.terrainPointClosest.latitude === 'number' &&
              typeof window.terrainPointClosest.longitude === 'number'
            ) {
              addMarker(
                window.terrainPointClosest.latitude,
                window.terrainPointClosest.longitude,
                'closest-point'
              )
            }
          }

          function setupMinimapListeners() {
            let _latitude = window.latitude
            Object.defineProperty(window, 'latitude', {
              get: function () {
                return _latitude
              },
              set: function (value) {
                _latitude = value
                updateMap()
              }
            })

            let _longitude = window.longitude
            Object.defineProperty(window, 'longitude', {
              get: function () {
                return _longitude
              },
              set: function (value) {
                _longitude = value
                updateMap()
              }
            })

            let _terrainPointClosest = window.terrainPointClosest
            Object.defineProperty(window, 'terrainPointClosest', {
              get: function () {
                return _terrainPointClosest
              },
              set: function (value) {
                _terrainPointClosest = value
                updateMap()
              }
            })
          }

          function updateMap() {
            if (
              window.terrainPointClosest &&
              typeof window.terrainPointClosest.latitude === 'number' &&
              typeof window.terrainPointClosest.longitude === 'number'
            ) {
              constructMap(
                window.terrainPointClosest.latitude,
                window.terrainPointClosest.longitude
              )
            } else if (window.latitude !== null && window.longitude !== null) {
              constructMap(window.latitude, window.longitude)
            } else {
              container.innerHTML = ''
              console.warn('Insufficient data to update the map.')
            }
          }

          setupMinimapListeners()
          updateMap()
        }

        initializeMinimap()

        // =========== Prevent Double-Tap Zoom on iOS ===========
        let lastTouchTime = 0
        document.addEventListener(
          'touchend',
          function (event) {
            const currentTime = Date.now()
            if (currentTime - lastTouchTime < 300) {
              event.preventDefault()
            }
            lastTouchTime = currentTime
          },
          false
        )

        // =========== Remove VR/XR disclaimers and prevent context menu ===========
        function removeVRXRDisclaimers() {
          const allATags = document.querySelectorAll('a')
          const allButtonTags = document.querySelectorAll('button')
          const vrbutton = document.getElementById('VRButton')

          allATags.forEach(aTag => {
            if (
              aTag.textContent.trim().toUpperCase() === 'WEBXR NOT AVAILABLE'
            ) {
              setTimeout(() => {
                aTag.remove()
              }, 5000)
            }
            if (aTag.textContent.trim().toUpperCase() === 'VR NOT SUPPORTED') {
              setTimeout(() => {
                aTag.remove()
              }, 5000)
            }
          })

          allButtonTags.forEach(buttonTag => {
            if (
              buttonTag.textContent.trim().toUpperCase() ===
              'WEBXR NOT AVAILABLE'
            ) {
              setTimeout(() => {
                buttonTag.remove()
              }, 5000)
            }
            if (
              buttonTag.textContent.trim().toUpperCase() === 'VR NOT SUPPORTED'
            ) {
              setTimeout(() => {
                if (vrbutton) vrbutton.remove()
              }, 5000)
            }
          })

          const touchControlsContainer =
            document.querySelector('.touch-controls')
          const touchControlsElements =
            document.querySelectorAll('.touch-control')
          if (touchControlsContainer) {
            touchControlsContainer.addEventListener('contextmenu', e =>
              e.preventDefault()
            )
          }
          touchControlsElements.forEach(element => {
            element.addEventListener('contextmenu', e => e.preventDefault())
          })
        }

        removeVRXRDisclaimers()

        // =========== Touch-based movement logic ===========
        function initializeTouchControls() {
          const isMobile = window.innerWidth <= 768 || window.innerHeight <= 768
          const touchControls = document.getElementById('touchControls')
          let visibilityTimeout

          if (isMobile) {
            document.body.addEventListener('touchstart', () => {
              showControls()
              resetVisibilityTimeout()
            })

            touchControls.addEventListener(
              'touchstart',
              handleTouchStart,
              false
            )
            touchControls.addEventListener('touchend', handleTouchEnd, false)
            touchControls.addEventListener('touchmove', handleTouchMove, false)
            touchControls.addEventListener(
              'touchcancel',
              handleTouchCancel,
              false
            )
          }

          document.addEventListener('gesturestart', function (event) {
            event.preventDefault()
          })
          document.addEventListener('gesturechange', function (event) {
            event.preventDefault()
          })
          document.addEventListener('gestureend', function (event) {
            event.preventDefault()
          })

          const keyMap = {
            forward: 'w',
            backward: 's',
            left: 'a',
            right: 'd',
            mic: 'r',
            egg: 'e',
            'forward-left': ['w', 'a'],
            'forward-right': ['w', 'd']
          }

          const activeKeys = new Set()

          function showControls() {
            touchControls.classList.add('active')
          }

          function hideControls() {
            touchControls.classList.remove('active')
          }

          function resetVisibilityTimeout() {
            if (visibilityTimeout) {
              clearTimeout(visibilityTimeout)
            }
            visibilityTimeout = setTimeout(hideControls, 10000)
          }

          function triggerKeyEvent(key, eventType) {
            const event = new KeyboardEvent(eventType, { key })
            document.dispatchEvent(event)
          }

          const controlCenters = {}

          const controls = document.querySelectorAll('.touch-control')
          controls.forEach(control => {
            const rect = control.getBoundingClientRect()
            const centerX = rect.left + rect.width / 2
            const centerY = rect.top + rect.height / 2
            controlCenters[control.classList[1]] = { x: centerX, y: centerY }
          })

          function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
          }

          const touchIdMap = new Map()

          function handleTouchStart(event) {
            resetVisibilityTimeout()
            const touches = event.changedTouches
            for (const touch of touches) {
              const target = touch.target
              const keysToActivate = new Set()

              for (const className in keyMap) {
                if (target.classList.contains(className)) {
                  const mappedKeys = Array.isArray(keyMap[className])
                    ? keyMap[className]
                    : [keyMap[className]]
                  mappedKeys.forEach(k => keysToActivate.add(k))
                }
              }

              if (keysToActivate.size === 0) {
                updateActiveKeys(touch.clientX, touch.clientY, keysToActivate)
              }

              keysToActivate.forEach(key => {
                if (!activeKeys.has(key)) {
                  activeKeys.add(key)
                  triggerKeyEvent(key, 'keydown')
                }
              })

              touchIdMap.set(touch.identifier, keysToActivate)
            }
          }

          function handleTouchMove(event) {
            resetVisibilityTimeout()
            const touches = event.changedTouches
            for (const touch of touches) {
              const previousKeys = touchIdMap.get(touch.identifier) || new Set()
              const newKeys = new Set()

              const target = document.elementFromPoint(
                touch.clientX,
                touch.clientY
              )
              if (target && target.classList) {
                for (const className in keyMap) {
                  if (target.classList.contains(className)) {
                    const mappedKeys = Array.isArray(keyMap[className])
                      ? keyMap[className]
                      : [keyMap[className]]
                    mappedKeys.forEach(k => newKeys.add(k))
                  }
                }
              }

              if (newKeys.size === 0) {
                updateActiveKeys(touch.clientX, touch.clientY, newKeys)
              }

              const keysToAdd = new Set(
                [...newKeys].filter(x => !previousKeys.has(x))
              )
              const keysToRemove = new Set(
                [...previousKeys].filter(x => !newKeys.has(x))
              )

              keysToAdd.forEach(k => {
                if (!activeKeys.has(k)) {
                  activeKeys.add(k)
                  triggerKeyEvent(k, 'keydown')
                }
              })

              keysToRemove.forEach(k => {
                if (activeKeys.has(k)) {
                  activeKeys.delete(k)
                  triggerKeyEvent(k, 'keyup')
                }
              })

              touchIdMap.set(touch.identifier, newKeys)
            }
          }

          function handleTouchEnd(event) {
            const touches = event.changedTouches
            for (const touch of touches) {
              const keys = touchIdMap.get(touch.identifier)
              if (keys) {
                keys.forEach(k => {
                  if (activeKeys.has(k)) {
                    activeKeys.delete(k)
                    triggerKeyEvent(k, 'keyup')
                  }
                })
                touchIdMap.delete(touch.identifier)
              }
            }
          }

          function handleTouchCancel(event) {
            handleTouchEnd(event)
          }

          function updateActiveKeys(touchX, touchY, keysToActivate) {
            const proximityThreshold = 50
            for (const [control, center] of Object.entries(controlCenters)) {
              const distance = calculateDistance(
                touchX,
                touchY,
                center.x,
                center.y
              )
              if (distance <= proximityThreshold) {
                const keyOrKeys = keyMap[control]
                if (keyOrKeys) {
                  if (Array.isArray(keyOrKeys)) {
                    keyOrKeys.forEach(k => keysToActivate.add(k))
                  } else {
                    keysToActivate.add(keyOrKeys)
                  }
                }
              }
            }
          }

          if (touchControls) {
            touchControls.addEventListener(
              'touchstart',
              handleTouchStart,
              false
            )
            touchControls.addEventListener('touchmove', handleTouchMove, false)
            touchControls.addEventListener('touchend', handleTouchEnd, false)
            touchControls.addEventListener(
              'touchcancel',
              handleTouchCancel,
              false
            )
          }

          // Swipe Gesture Detection
          let touchStartX = null
          let touchStartY = null
          const swipeThreshold = 50

          document.addEventListener(
            'touchstart',
            function (e) {
              const touch = e.changedTouches[0]
              touchStartX = touch.screenX
              touchStartY = touch.screenY
            },
            false
          )

          document.addEventListener(
            'touchend',
            function (e) {
              if (touchStartX === null || touchStartY === null) {
                return
              }

              const touch = e.changedTouches[0]
              const touchEndX = touch.screenX
              const touchEndY = touch.screenY

              const deltaX = touchEndX - touchStartX
              const deltaY = touchEndY - touchStartY

              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (Math.abs(deltaX) > swipeThreshold) {
                  if (deltaX > 0) {
                    triggerKeyEvent('d', 'keydown')
                    setTimeout(() => triggerKeyEvent('d', 'keyup'), 300)
                  } else {
                    triggerKeyEvent('a', 'keydown')
                    setTimeout(() => triggerKeyEvent('a', 'keyup'), 300)
                  }
                }
              } else {
                if (Math.abs(deltaY) > swipeThreshold) {
                  if (deltaY > 0) {
                    triggerKeyEvent('s', 'keydown')
                    setTimeout(() => triggerKeyEvent('s', 'keyup'), 300)
                  } else {
                    triggerKeyEvent('w', 'keydown')
                    setTimeout(() => triggerKeyEvent('w', 'keyup'), 300)
                  }
                }
              }

              touchStartX = null
              touchStartY = null
            },
            false
          )
        }

        initializeTouchControls()

        // =========== Update Position Div ===========
        function updatePositionDiv() {
          const positionDiv = document.getElementById('position')

          if (!positionDiv) {
            console.warn("Element with ID 'position' not found.")
            return
          }

          if (!window.terrainPointClosest) {
            console.warn('window.terrainPointClosest is undefined.')
            return
          }

          const { latitude, longitude, elevation } = window.terrainPointClosest
          positionDiv.innerHTML = `
          <div>Latitude: ${latitude}</div>
          <div>Longitude: ${longitude}</div>
          <div>Elevation: ${elevation}</div>
        `
        }

        updatePositionDiv()
        setInterval(updatePositionDiv, 1000)

        // =========== Initializations ===========
        attachClearButtonHandler()
        updateTime()
        fetchIPAddress()
        setInterval(updateTime, 1000)
        initializePermissionDemo()
      })
    </script>

    <script type="module" src="/src/app.js"></script>
  </body>
</html>
